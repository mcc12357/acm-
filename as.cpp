#include <iostream>

using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 11;

int res = 0;    //  打爆首尾需要的次数
int res_2 = INF;//  打爆中间的需要的最少次数
int n, a, b;
int H[MAXN];    //  生命值

//  暴力深搜
void dfs(int N, int ans)
{
    //  当到达第n个人时，更新最少的爆破次数，并返回
    if (N == n)
    {
        res_2 = res_2 > ans ? ans : res_2;
        return ;
    }
    //  每次向后搜索都要保证第N-1个为负数
    if (H[N - 1] < 0)
    {
        dfs(N + 1, ans);
    }
    int times = 0;
    //  必须在第N位置爆times次才能保证第N-1个为负数
    if (H[N - 1] >= 0)
    {
        times = H[N - 1] / b + 1;
        H[N - 1] -= b * times;
        H[N] -= a * times;
        H[N + 1] -= b * times;
        dfs(N + 1, ans + times);
        H[N - 1] += b * times;
        H[N] += a * times;
        H[N + 1] += b * times;
    }
    //  只要爆times~times_次都能保证第N-1个为负数
    int times_ = H[N] / a + 1;
    if (H[N] >= 0 && times_ > times)
    {
        for (int i = times + 1; i <= times_; i++)
        {
            H[N - 1] -= b * i;
            H[N] -= a * i;
            H[N + 1] -= b * i;
            dfs(N + 1, ans + i);
            H[N - 1] += b * i;
            H[N] += a * i;
            H[N + 1] += b * i;
        }
    }

    return ;
}

int main(int argc, const char * argv[])
{
//    freopen("/Users/zyj/Desktop/input.txt", "r", stdin);

    cin >> n >> a >> b;

    for (int i = 1; i <= n; i++)
    {
        cin >> H[i];
    }

    //  打爆第1个
    int times = H[1] / b + 1;
    res += times;
    H[1] -= b * times;
    H[2] -= a * times;
    H[3] -= b * times;

    //  打爆第n个
    if (H[n] >= 0)
    {
        times = H[n] / b + 1;
        res += times;
        H[n] -= b * times;
        H[n - 1] -= a * times;
        H[n - 2] -= b * times;
    }

    dfs(2, 0);

    //  保证res_2是有效次数
    if (res_2 == INF)
    {
        res_2 = 0;
    }

    std::cout << res + res_2 << '\n';
    return 0;
}